-- @nsURI UmlMm=http://DSM/DC_UML
-- @nsURI ErMm=http://DSM/ER_2025

module T9;
create OUT : ErMm from IN : UmlMm;

-- Helper global para buscar tablas por nombre
helper def: lookupTabla(diagrama : UmlMm!Diagrama, tableName : String) : ErMm!Tabla =
  let esquema : ErMm!Esquema = thisModule.resolveTemp(diagrama, 'esq')
  in if esquema <> OclUndefined then
      esquema.tablas->select(t | t.nombre = tableName)->first()
     else
      OclUndefined
     endif;

-- Genera los esquemas
rule Diagrama_Esquema {
	from
		d : UmlMm!Diagrama  
	to
		esq : ErMm!Esquema(
			nombre <- d.nombre.debug('Creando esquema'),
			tablas <- d.clases->collect(c | thisModule.Clase_Tabla(c))
		)
}

-- Genera las tablas para clases
unique lazy rule Clase_Tabla {
	from
		c : UmlMm!Clase
	to
		tabla : ErMm!Tabla(
			nombre <- c.nombre.debug('Creando tabla'),
			columnas <- (
				c.atributos->collect(a | thisModule.Create_Data_column(a))
				->append(thisModule.Create_ID_column(c))
			)
		)
}

-- Genera las columnas normales de la tabla
unique lazy rule Create_Data_column {
	from
		a : UmlMm!Atributo
	to
		col : ErMm!Columna(
			nombre <- a.nombre.debug('Creando columna'),
			rango <- a.max,
			esUnico <- if a.max = 1 then true else false endif,
			esNulo <- if a.min = 0 then true else false endif,
			tipo <- a.getType()
		)
}

-- Genera la columna ID de la tabla
unique lazy rule Create_ID_column {
	from
		c: UmlMm!Clase
	to
		id_col: ErMm!Columna(
			nombre <- c.nombre + '_id'.debug('Creando tabla id'), 
			tipo <- #integer,
			esPrimaria <- true,
			esUnico <- true,
			rango <- -1
		)
}

-- Helper para obtener el tipo del atributo
helper context UmlMm!Atributo def: getType() : ErMm!TiposER = 
	if self.tipo = #entero then #integer
	else if self.tipo = #boolean then #integer
	else if self.tipo = #cadena then #string
	else if self.tipo = #real then #double
	else if self.tipo = #fecha then #fecha
	else #integer 
	endif endif endif endif endif;

-- Regla para generar FKs para relaciones de herencia
rule Herencia_ClaveAjena {
  from
    clase : UmlMm!Clase (
      -- Solo procesa clases que tienen un padre
      not clase.generaliza.oclIsUndefined()
    )
  using {
    esquema : ErMm!Esquema = thisModule.resolveTemp(clase.diagrama, 'esq').debug('Retrieved esquema for inheritance: ');
    clasePadre : UmlMm!Clase = clase.generaliza.debug('Parent class: ');
    
    -- Encuentra las tablas para las clases hija y padre
    tablaHija : ErMm!Tabla = thisModule.lookupTabla(clase.diagrama, clase.nombre).debug('Child table: ');
    tablaPadre : ErMm!Tabla = thisModule.lookupTabla(clasePadre.diagrama, clasePadre.nombre).debug('Parent table: ');

    -- Encuentra las columnas ID para las clases hija y padre
    pkPadre : ErMm!Columna = 
      if tablaPadre <> OclUndefined then
        tablaPadre.columnas->select(c | c.esPrimaria)->first().debug('Parent PK found: ')
      else
        OclUndefined
      endif;
  }
  to
    -- Columna FK en la tabla hija
    fk : ErMm!Columna (
      nombre <- (clasePadre.nombre + '_id').debug('Creating inheritance FK column named: '),
      tipo <- if pkPadre <> OclUndefined then pkPadre.tipo else #integer endif,
      esUnico <- true,
      esNulo <- false,
      rango <- 1,
      tabla <- tablaHija,
      claveAjena <- claveAjenaHerencia
    ),
    
    -- RestricciÃ³n de FK para la herencia
    claveAjenaHerencia : ErMm!ClaveAjena (
      nombre <- ('FK_' + clase.nombre + '_inherits_' + clasePadre.nombre).debug('Creating inheritance constraint named: '),
      esquema <- esquema,
      columna <- fk,
      referenciada <- pkPadre
    )
  do {
    ('Finished processing inheritance relationship between: ' + clase.nombre + ' and ' + clasePadre.nombre).debug();
  }
}
