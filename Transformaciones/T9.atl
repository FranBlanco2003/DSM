-- @nsURI UmlMm=http://DSM/DC_UML
-- @nsURI ErMm=http://DSM/ER_2025

module T9;
create OUT : ErMm from IN : UmlMm;

-- genera los esquemas
rule Diagrama_Esquema{
	from
		d : UmlMm!Diagrama  
	to
		esq : ErMm!Esquema(
			nombre <- d.nombre.debug('Creando esquema'),
			tablas <- d.clases->collect(c | thisModule.Clase_Tabla(c))
		)
}

-- genera las claves ajenas
rule Relacion_ClaveAjena{
	from
		r : UmlMm!Relacion
	using
		{
			-- extremos de la relacion
			extremos : Sequence(UmlMm!FinRelacion) = r.finRelacion->asSequence();
			extremo1 : UmlMm!FinRelacion = extremos->first();
			extremo2 : UmlMm!FinRelacion = extremos->last();
			
			extremoDependiente : UmlMm!FinRelacion = extremo1; -- resultado por defecto del extremo dependiente
			extremoIndependiente : UmlMm!FinRelacion = extremo2; 
			
			esquema : ErMm!Esquema = thisModule.resolveTemp(r.diagrama, 'esq');
		}
	to
		fk : ErMm!ClaveAjena(
			nombre <- (extremo1.rol + '_to_' + extremo2.rol).debug('Creando clave ajena'),
			esquema      <- esquema,
            columna      <- loc,
            referenciada <- r.lookupTabla(extremoIndependiente.clase.nombre).columnas
							->select(c | c.esPrimaria)
							->first()                 
		), 
		-- Columna local de la parte dependiente
		loc : ErMm!Columna(
			nombre <- (extremoDependiente.rol + '_ref_' + extremoIndependiente.rol).debug('Creada columna dependiente'),
			rango <- extremoDependiente.max, -- ¿Que es el rango?
			esUnico <- if extremoDependiente.max = 1 then true else false endif,
			esNulo <- if extremoDependiente.min = 0 then true else false endif, -- ¿esto deberia estar?
			tipo <- #integer,
			tabla <- r.lookupTabla(extremoDependiente.clase.nombre)
		)
	do{
		-- limitado a 1 - 1 y 0 - 1
		if (extremo1.max = 1 and extremo2.max = 1) {
			-- Si el 2º fin es mas dependiente que el primero, lo marcamos. Si no, usamos el primero
			if (extremo2.composicion or extremo2.max = 1 and extremo2.min = 1){
					extremoDependiente = extremo2;
					extremoIndependiente = extremo1;
			}
		}
		else {
			-- Cubre caso 0/1..* - 0/1..1
			if ((extremo1.max = -1 and extremo2.max = 1) or (extremo1.max = 1 and extremo2.max = -1)){
				if (extremo2.max = -1){
					extremoDependiente = extremo2;
					extremoIndependiente = extremo1;
				}
			}
			-- Falta caso muchos a muchos
		}
	}
}

helper context UmlMm!Relacion def: lookupTabla(tableName : String) : ErMm!Tabla =
  -- 1) Obtengo el Esquema ER asociado al Diagrama de esta Relación
  let esquema : ErMm!Esquema =
    thisModule
      .resolveTemp(self.diagrama,    -- la UmlMm!Diagrama
                   'esq')           -- target‐pattern name de Diagrama_Esquema
  in
  -- 2) Del Esquema, filtro sus tablas por nombre
  esquema
    .tablas                       -- colección ErMm!Tabla
    ->select(t | t.nombre = tableName)
	->first() -- Obtenemos la unica
;

-- genera una tabla
unique lazy rule Clase_Tabla{
	from
		c : UmlMm!Clase
	to
		tabla: ErMm!Tabla(
			nombre <- c.nombre.debug('Creando tabla'),
			columnas <- (
					c.atributos->collect(a | thisModule.Create_Data_column(a)
				)->append(
					thisModule.Create_ID_column(c)
				)	
			)
		)
}

-- genera las columnas normales de la tabla
unique lazy rule Create_Data_column{
	from
		a : UmlMm!Atributo
	to
		col: ErMm!Columna(
			nombre <- a.nombre.debug('Creando columna'),
			rango <- a.max, -- ¿Que es el rango?
			esUnico <- if a.max = 1 then true else false endif,
			esNulo <- if a.min = 0 then true else false endif, -- ¿esto deberia estar?
			tipo <- a.getType()
		)
}

-- obtiene el tipo de la columna a partir del tipo del elemeto
helper context UmlMm!Atributo def: getType() : ErMm!TiposER = 
	if (self.tipo = #entero or self.tipo = #boolean) then #integer
	else 
		if self.tipo = #cadena then #string
		else 
			if self.tipo = #real then #double
			else 
				if self.tipo = #fecha then #fecha
				else #integer 
				endif
			endif
		endif
	endif;

-- genera la columna ID de la tabla
unique lazy rule Create_ID_column{
	from
		c: UmlMm!Clase
	to
		id_col: ErMm!Columna(
			nombre <- c.nombre + '_id'.debug('Creando tabla id'), 
			tipo <- #integer,
			esPrimaria <- true,
			esUnico <- true,
			rango <- -1
		)
}
--8.Generación de FKs en tablas correspondientes a Clases Asociación
rule ClaseAsociacion_Tabla {
  from
    ca : UmlMm!ClaseAsociacion
  using {
    -- Debug the association class being processed
    nombreCA : String = ca.nombre.debug('Processing ClaseAsociacion: ');
    esquema : ErMm!Esquema = thisModule.resolveTemp(ca.diagrama, 'esq').debug('Retrieved esquema: ');
    clase1 : UmlMm!Clase = ca.asociacion.finRelacion->first().clase.debug('First class: ');
    clase2 : UmlMm!Clase = ca.asociacion.finRelacion->last().clase.debug('Second class: ');
    -- Create tables for related classes if they don't exist
    tabla1 : ErMm!Tabla = thisModule.Clase_Tabla(clase1).debug('Created/Retrieved tabla1: ');
    tabla2 : ErMm!Tabla = thisModule.Clase_Tabla(clase2).debug('Created/Retrieved tabla2: ');
  }
  to
    tabla : ErMm!Tabla (
      nombre <- ca.nombre.debug('Creating association table: '),
      esquema <- esquema,
      columnas <- Sequence{
        thisModule.Create_ID_column(ca).debug('Created ID column: '),
        fk1.debug('Created FK1: '), 
        fk2.debug('Created FK2: ')
      }->union(
        ca.atributos->collect(a | thisModule.Create_Data_column(a).debug('Created attribute column: '))
      )
    ),
    -- FK column for first related class
    fk1 : ErMm!Columna (
      nombre <- (clase1.nombre + '_ref').debug('Creating FK1 column named: '),
      tipo <- #integer,
      esUnico <- false,
      esNulo <- false,
      rango <- -1,
      tabla <- tabla,
      claveAjena <- claveAjena1
    ),
    -- FK column for second related class  
    fk2 : ErMm!Columna (
      nombre <- (clase2.nombre + '_ref').debug('Creating FK2 column named: '), 
      tipo <- #integer,
      esUnico <- false,
      esNulo <- false,
      rango <- -1,
      tabla <- tabla,
      claveAjena <- claveAjena2
    ),
    -- Create foreign key constraint for first class
    claveAjena1 : ErMm!ClaveAjena (
      nombre <- ('FK_' + ca.nombre + '_' + clase1.nombre).debug('Creating FK1 constraint named: '),
      esquema <- esquema,
      columna <- fk1,
      referenciada <- thisModule.resolveTemp(clase1, 'id_col').debug('FK1 references ID column: ')
    ),
    -- Create foreign key constraint for second class
    claveAjena2 : ErMm!ClaveAjena (
      nombre <- ('FK_' + ca.nombre + '_' + clase2.nombre).debug('Creating FK2 constraint named: '),
      esquema <- esquema,
      columna <- fk2,
      referenciada <- thisModule.resolveTemp(clase2, 'id_col').debug('FK2 references ID column: ')
    )
  do {
    ('Finished processing ClaseAsociacion: ' + ca.nombre).debug();
  }
}
-- 9 Regla para generar claves ajenas en relaciones de herencia
-- Rule to handle inheritance relationships by creating foreign keys
rule Herencia_ClaveAjena {
  from
    clase : UmlMm!Clase (
      -- Only process classes that have a parent (generaliza)
      not clase.generaliza.oclIsUndefined()
    )
  using {
    esquema : ErMm!Esquema = thisModule.resolveTemp(clase.diagrama, 'esq').debug('Retrieved esquema for inheritance: ');
    padreClase : UmlMm!Clase = clase.generaliza.debug('Parent class: ');
    nombreClase : String = clase.nombre.debug('Processing child class: ');
    nombrePadre : String = padreClase.nombre.debug('With parent class: ');
    -- Get the tables for both classes
    tablaHija : ErMm!Tabla = thisModule.Clase_Tabla(clase).debug('Child table: ');
    tablaPadre : ErMm!Tabla = thisModule.Clase_Tabla(padreClase).debug('Parent table: ');
  }
  to
    -- Foreign key column in child table
    fk : ErMm!Columna (
      nombre <- (nombrePadre + '_id').debug('Creating inheritance FK column named: '),
      tipo <- #integer,
      esUnico <- true,  -- One-to-one relationship in inheritance
      esNulo <- false,  -- Cannot be null as every child must have a parent
      rango <- 1,
      tabla <- tablaHija,
      claveAjena <- claveAjenaHerencia
    ),
    
    -- Foreign key constraint
    claveAjenaHerencia : ErMm!ClaveAjena (
      nombre <- ('FK_' + nombreClase + '_inherits_' + nombrePadre).debug('Creating inheritance constraint named: '),
      esquema <- esquema,
      columna <- fk,
      referenciada <- thisModule.resolveTemp(padreClase, 'id_col').debug('Inheritance FK references parent ID column: ')
    )
  do {
    ('Finished processing inheritance relationship between: ' + nombreClase + ' and ' + nombrePadre).debug();
  }
}